package ch5.item31;

/*
 * item31. 한정적 와일드카드를 사용해 API 유연성을 높여라
 *
 *  매개변수화 타입은 불공변
 * List<String>은 List<Object>의 하위 타입이 아니라는 의미인데
 * List<Object>에는 어떤 객체든 넣을 수 있지만
 * List<String>에는 문자열만 넣을 수 있으므로
 * List<String>이 List<Object>가 하는 일을 수행하지 못하므로
 * 하위 타입이 아니라고 할 수 있음
 *  하지만 때로는 불공변보다 유연한 방식이 필요함
 * Stack<Number>에 pushALL(Integer)를 호출하면
 * Integer가 Number의 하위 타입이므로 잘 동작해야 할 것 같지만
 * 매개변수화 타입이 공변이므로 오류가 발생
 * 이런 때를 위해 한정적 와일드카드 타입이라는 특수 매개변수화 타입 지원
 * E의 하위 타입을 매개변수로 받도록 <? extends E> 를 사용할 수 있음
 *  이번엔 Stack<Number>의 원소를 Object 컬렉션으로 옮기려는데
 * 마찬가지로 오류가 발생함
 * E의 상위 타입을 매개변수로 받도록 <? super E> 를 사용할 수 있음
 *  위 예시를 통해서, 유연성을 극대화하려면
 * 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하는 게 좋음
 * 반면, 입력 매개변수가 생산자와 소비자 역할을 동시에 하면
 * 타입을 정확히 지정해야 하는 상황으로, 와일드카드 타입을 쓰면 안됨
 *  그러니까 T가 생산자면 하위 타입도 받을 수 있도록 ? extends T,
 * 소비자라면 상위 타입과도 맞도록 ? super T를 사용
 *  추가로, 반환 타입에는 한정적 와일드카드 타입을 사용하면 안되는데,
 * 유연성을 높여주지 못하고 클라이언트 코드에서도 와일드카드 타입을 쓰게 강요
 * 클래스 사용자가 와일드카드 타입을 신경써야한다면 문제가 있는 API
 *  타입 매개변수와 와일드카드에는 공통된 부분이 있어서,
 * 메소드 정의 시 둘 중 어느걸 사용해도 괜찮은 경우겨 많음
 * 기본 규칙은 메소드 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체
 * 비한정적 타입 매개변수 -> 비한정적 와일드카드
 * 한정적 타입 매개변수 -> 한정적 와일드카드
 */
public class item31 {
}
