package ch5.item32;

import java.util.List;
import java.util.Objects;

/*
 * item32. 제네릭과 가변인수를 함께 쓸 때는 신중하라
 *
 *  가변인수 메소드와 제네릭은 잘 어우러지지 않음
 * 가변인수는 메소드에 넘기는 인수 개수를 클라이언트가 조절할 수 있게 해주는데
 * 가변인수 메소드를 호출하면 가변인수를 담기 위한 배열이 자동으로 만들어짐
 * 그런데 이 배열을 클라이언트에 노출하는 문제가 있어
 * varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 컴파일 경고가 발생
 *  실체화 불가 타입은 런타임에는 컴파일타임보다 타입 관련 정보를 적게 담고 있고
 * 거의 모든 제네릭과 매개변수화 타입은 실체화되지 않는데
 * 메소드를 선언할 때 실체화 불가 타입으로 varargs 매개변수를 선언하면 경고가 발생
 * 가변인수 메소드를 호출할 때도 varargs 매개변수가 실체화 불가 타입으로 추론되면,
 * 그 호출에도 경고를 보냄
 * 배개변수화 타입의 변수가 다른 객체를 참조하면 힙 오염이 발생
 * 이렇게 다른 타입 객체를 참조하는 상황에서는
 * 컴파일러가 자동 생성한 형변환이 실패할 수 있으므로,
 * 제네릭 시스템의 타입 안전성의 근간이 흔들리게 됨
 * 따라서 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않음
 *  제네릭 배열을 프로그래머가 직접 생성하는 것은 허용하지 않는데
 * 제네릭 varargs 매개변수를 받는 메소드를 선언할 수 있게 한 이유는
 * 제네릭이나 매개변수화 타입의 varargs 매개볁수를 받는 메소드가 매우 유용하기 때문
 *  자바 7 전 사용자는 경고를 그냥 두거나 숨겨야했음
 *  자바 7에서는 @SafeVarargs 어노테이션이 추가되어
 * 제네릭 가변인수 메소드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있음
 * @SafeVarargs 어노테이션은 메소드 작성자가 그 메소드가 타입 안전함을 보장하는 장치
 * 따라서 메소드의 안전을 확실할 수 없다면 @SafeVarargs를 달면 안됨
 *  메소드가 varargs 매개변수 제네릭 배열을 덮어쓰지 않고
 * 참조가 밖으로 노출되지 않다면 타입 안전하다고 할 수 있음
 *  이 때, varargs 매개변수 배열에 아무것도 저장하지 않고도 타입 안전성을 깰 수도 있는데
 * varargs 매개변수를 반환하면 반환값을 받는 코드로 인해
 * 자동 형변환이 발생할 수 있는데, 여기서 형변환 예외가 발생할 수 있음
 *  이처럼 제네릭 varargs 매개변수 배열에 다른 메소드가 접근을 허용하면 안전지 않음
 * 하지만 예외가 두 가지 존재
 * 1. @SafeVarargs로 어노테이트된 또 다른 varargs 메소드에 넘기는 것은 안전
 * 2. 이 배열 내용의 일부 함수를 호출만 하는 일반 메소드에 넘기는 것도 안전함
 *  @SafeVarargs 어노테이션이 유일한 정답은 아니고,
 * varargs 매개변수를 List 매개변수로 바꿀 수도 있음
 * (List.of(...varargs))
 * 왜냐하면 List.of에도 @SafeVarargs가 달려 있기 때문
 * 이 방식의 장점은 컴파일러가 이 메소드 타입 안전성을 검증할 수 있으며
 * 어노테이션도 필요 없고, 실수로 안전하다 판단할 걱정도 없음
 * 단, 코드가 살짝 지저분해지고 속도가 조금 느려질 수 있음
 *  이 방식은 varargs 메소드를 안전하게 작성하는 게 불가능한 상황에도 사용 가능
 *
 */
public class item32 {

    static void dangerous(List<String>... stringLists) {
        List<Integer> intList = List.of(42);
        Object[] objects = stringLists;
        objects[0] = intList; // 힙 오염
        String s = stringLists[0].get(0); // ClassCastException
    }
}
