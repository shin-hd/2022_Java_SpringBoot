package ch8.item50;

/*
 * item50. 적시에 방어적 복사본을 만들라
 *
 *  자바는 안전한 언어지만 다른 클래스로부터의 침범을 아무런 노력 없이
 * 다 막을수는 없으므로, 클라이언트가 불변식을 깨뜨리려 한다고 가정하고
 * 방어적으로 프로그래밍해야 함
 *
 *  어떤 객체든 그 객체의 허락 없이 외부에서 내부를 수정할 수 없어야 하지만,
 * 자기도 모르게 내부를 수정하도록 허락하는 경우가 빈번함
 * 예를 들어 Date같은 가변 객체를 final로 선언해도 해당 객체는 외부에서 수정 가능
 * 앞으로 가변 객체를 안쓴다고 해도, 많은 API와 내부 구현에 가변 객체가 남아있어서
 * 이를 대처하기 위한 방법이 필요
 * => 생성자에서 받은 가변 매개변수 각각을 방어적 복사
 * 
 *  매개변수 유효성을 검사하기 전에
 * 방어적 복사본을 만들고 유효성을 검사함
 * 순서가 이상하게 느껴질 수 있는데, 멀티스레딩 환경이라면
 * 유효성 검사하고 복사하는 사이에 다른 스레드가 수정할 수 있기 때문
 * : 검사시점/사용시점 공격(TOCTOU 공격)
 *
 *  방어적 복사에 clone 메소드를 사용하지 않는데,
 * clone이 악의적인 하위 클래스 인스턴스를 반환할 수 있기 때문
 *
 *  접근자 메소드가 내부 가변 정보를 직접 드러낸다먼 외부에서 수정할 수 있으므로,
 * 접근자는 가변 필드의 방어적 복사본을 반환해야 함
 *  접근자 메소드에서는 객체의 타입이 확실하니까 clone을 사용해도 됨
 *
 *  매개변수를 방어적으로 복사하는 목적은 불변 객체를 만들기 위헤서뿐만 아니라
 * 객체가 잠재적으로 변경되어서 클래스 동작에 문제가 발생하지 않도록 하는 것
 * 길이 1 이상인 배열은 무조건 가변임으로
 * 방어적 복사를 수행하거나 불변 뷰를 반환
 *
 *  정리하자면, 되도록 불변 객체를 조합해서 객체를 구성해야
 * 방어적 복사를 사용할 일이 줄어듦
 *  방어적 복사는 성능을 저하시키고 항상 쓸 수 있는 것이 아니기 때문에
 * 호출자가 객체 내부를 수정하지 않을 것이라 확신한다면
 * 방어적 복사를 생략하고 문서화해야 함
 *
 *  다른 패키지에서 사용하더라도 항상 방어적 복사를 사용해야 하는 것은 아님
 * 매개변수로 넘기는 행위가 객체 통제권을 이전함을 의미할 때도 있음
 * 클라이언트는 매개변수로 넘긴 다음 해당 객체를 수정하지 않도록 해야 하고,
 * 메소드나 생성자에서도 통제권을 넘겨받음을 확실히 문서화해야 함
 *  통제권을 넘겨받는 메소드나 생성자를 가진 클래스는
 * 악의적 클라이언트의 공격에 취약하기 때문에
 * 클라이언트를 신뢰할 수 있거나, 불변이 깨지더라도 영향이
 * 호출한 클라이언트에게만으로 국한될 때 방어적 복사를 생략
 * 
 * 
 * 
 */
public class item50 {
}
