package ch4.item15;

/*
 * 클래스와 멤버의 접근 권한을 최소화하라
 * 
 * 어설픈 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는
 * 클래스 내부 데이터와 내부 구현 정보를 얼마나 잘 숨겼는지
 * API를 통해서만 소통, 서로의 내부 동작방식에는 개의치 않아야
 * (정보은닉, 캡슐화)
 *
 * 정보은닉의 장점(모듈화?)
 * 1. 여러 컴포넌트를 병렬로 개발해서 시스템 개발 속도를 높임.
 * 2. 컴포넌트를 빠르게 파악해서 디버깅할 수 있고 컴표넌트 교체 부담도 적어
 *    시스템 관리 비용을 낮춤.
 * 3. 성능을 높여주진 않지만, 컴포넌트 단위로 최적화할 수 있어서
 *    성능 최적화에 도움을 줌.
 * 4. 독자적으로 동작하는 컴포넌트라면 다른 환경에서도 쓰일 가능성이 커서
 *    소프트웨어 재사용성을 높인다.
 * 5. 컴포넌트 단위로 동작 검증이 가능해서
 *    큰 시스템을 제작하는 난이도를 낮춰준다.
 *
 * 접근 제한자를 활용하는 것이 정보 은닉의 핵심
 * - 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 함
 *
 * 톱레벨 클래스, 인터페이스
 * package-private : 내부 구현이 되어 언제든 수정, 교체, 제거 가능
 * public : 공개 API. 영원히 관리해줘야
 *
 * 멤버(필드, 메소드, 중첩 클래스, 중첩 인터페이스)
 * private : 공개 API 외의 모든 멤버
 * package-private : 같은 패키지의 다른 클래스가 접근해야 하는 멤버
 * protected : 공개 대상 범위가 엄청 넓어지고,
 *             public 클래스의 protected 멤버는 공개 API이므로 영원히 지원되야 함.
 *             내부 동작 방식을 문서화해서 공개해야 할 수도 있음.
 *             protected 멤버 수는 적을수록 좋음.
 * public : 상위 클래스의 메소드 재정의할 때 상위 클래스보다 좁게 설정할 수 없음.
 *          클래스는 인터페이스가 정의한 모든 메소드를 public으로 선언해야 함.
 *
 * 코드 테스트 목적으로는 적당한 수준까지 넓혀도 괜찮다.
 * 예를 들어, public 클래스 private 멤버 -> package-private까지 풀어주는 것 까지
 * 테스트를 위해 공개 API로 만들기는 X
 *
 * public 클래스 인스턴스 필드는 되도록 public이 아니어야 한다.
 * 필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면
 * 필드 값을 제한할 힘을 잃게 된다.
 * 필드가 수정될 때 다른 작업을 할 수 없게 되므로 스레드 안전하지 않다.
 * 심지어 필드가 (public?) final이어서 불변 객체를 참조하더라도
 * public 필드를 없애는 방식으로는 리팩토링 불가
 *
 * 예외) 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 구성요소로써의 상수라면
 * public static final 필드를 공개해도 좋음
 *
 * 길이가 0이 아닌 배열은 모두 변경 가능하다.
 * 따라서 클래스에서 public static final 배열 필드를 두거나
 * 필드를 반환하는 접근자 메소드를 제공하면 안된다.
 * 예) public static final Thing[] VALUES;
 *
 * 어떤 IDE가 생성하는 접근자는 private 배열 필드의 참조를 반환해서 문제를 일으킨다.
 * 해결책
 * 1. 배열을 private으로 만들고 public 불변 리스트 추가
 *    private static final Thing[] PRIVATE_VALUES;
 *    public static final List<Thing> VALUES =
 *      Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
 * 2. private으로 배열을 만들고 복사본을 반환하는 public 메소드
 *    private static final Thing[] PRIVATE_VALUES;
 *    public static final Thing[] values() {return PRIVATE_VALUES.clone();}
 * 클라이언트 필요에 따라 선택
 *
 * 자바9부터 모듈 시스템 개념이 도입되면서 두 가지 암묵적 접근 수준이 추가
 * 패키지 = 클래스 묶음, 모듈 = 패키지 묶음
 * 모듈은 속하는 패키지 중 공개(export)할 것들을 선언함
 * 모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서
 * 같은 모듈을 이루는 패키지간 자유롭게 공유 가능
 * 모듈 내부로 한정되는 public, protected 수준
 *
 * 모듈에 적용되는 접근 수준은 주의해서 사용해야 함
 * 모듈의 JAR 파일을 앱 클래스패스에 두면 모듈이 없는 것처럼 행동
 * 즉, public, protected 멤버를 모듈 밖에서 접근 가능
 *
 * 모듈의 장점을 제대로 누리려면 해야 할 일이 많으므로
 * 꼭 필요한 경우에만 사용하도록
 */
public class item15 {
}
