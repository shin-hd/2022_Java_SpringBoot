package ch4.item21;

/*
 * 인터페이스는 구현하는 쪽을 생각해 설계하라
 *
 *  디폴트 메소드를 선언하면 디폴트 메소드를 재정의하지 않은 모든 클래스에서
 * 디폴트 구현이 쓰이게 됨
 * 하지만 이 메소드가 모든 구현체들과 연동되리란 보장이 없음
 * 1. 가능한 모든 상황에서 불변식을 해치지 않는 디폴트 메소드를 작성하는 건 어려움
 *  예를 들어, 아파치의 SynchronizedCollection 클래스는
 * 락을 거는 능력을 추가로 제공하는 래퍼 클래스인데,
 * removeIf 디폴트 메소드를 재정의하지 않고 있으므로
 * removeIf를 호출하면 예외가 발생하거나 예상 못한 결과를 야기할 수 있음
 * 2. 디폴트 메소드는 기존 구현체에 런타임 오류를 일으킬 수 있음
 *  기존 인터페이스에 디폴트 메소드로 새 메소드를 추가하는 일은 피해야 함
 * 또한 기존 구현체들과 충돌할지 충분히 심사숙고해야 함
 * 3. 디폴트 메소드라는 도구가 있더라도 인터페이스를 설계할 때는 세심한 주의를 기울여야 함
 * 기존 인터페이스에 디폴트 메소드를 추가하면 위험도 따라오게 되어
 * 인터페이스를 포함한 API에 어떤 재앙을 몰고 올지 알 수 없음
 * 4. 인터페이스를 릴리스한 후에 결함을 수정할 수 있을 가능성에 기대선는 안됨
 * 새로운 인터페이스라면 릴리스 전에 반드시 테스트를 거쳐야 함
 * 다른 방식으로 최소 세 가지씩 구현해보고
 * 클라이언트도 여러 개 만들어 봐야 함
 *
 */
public class item21 {
}
