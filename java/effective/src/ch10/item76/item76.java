package ch10.item76;

/*
 * item76. 가능한 한 실패 원자적으로 만들라
 *
 *  호출된 메소드가 실패하더라도 객체는 메소드 호출 전 상태를 유지해야 함
 * : 실패 원자적
 *
 *  메소드를 실패 원자적으로 만드는 방법
 * 1. 불변 객체로 설계
 *  불변 객체는 실패하면 새로운 객체가 만들어지지 않을 수는 있지만
 *  기존 객체가 불안정한 상태에 빠지는 일은 절대 없으므로 실패 원자적임
 *
 *  가변 객체의 메소드에 적용하는 방법
 * 2. 매개변수의 유효성 검사
 *  객체 내부 상태를 변경하기 전에 잠재적 예외 가능성 대부분을 걸러낼 수 있음
 *  계산을 수행해보기 전에는 유효성 검사를 할 수 없을 때는
 *  유효성 검사 기법에 덧붙여서 실패할 가능성이 있는 모든 코드를
 *  객체의 상태를 바꾸는 코드보다 앞에 배치하는 방법
 * 3. 객체의 임시 복사본에서 작업을 수행한 다음,
 *    성공적으로 완료되면 원래 객체와 교환하는 방법
 * 4. 작업 도중에 발생하는 실패를 가로채는 복구 코드를 작성해서
 *    작업 전 상태로 되돌리는 방법
 *  주로 내구성을 보장해야 하는 자료구조에 쓰임
 *
 *  실패 원자성은 권장되는 덕목이지만 항상 달성할 수 있는 것은 아님
 * ex) 두 스레드가 동기화 없이 같은 객체를 수정하면 일관성이 깨짐
 * 따라서 ConcurrentModificationException을 잡았다고 해서
 * 해당 객체가 쓸 수 있는 상태임을 보장하지 않음
 * Error는 복구불가능하므로
 * AssertionError에 대해서는 실패 원자성으로 만들 시도조차 할 필요가 없음
 *
 *  실패 원자성을 달성하기 위한 비용이나 복잡도가 아주 큰 경우
 * 실패 원자적으로 만들 수 있더라도 하지 않는게 나을 수 있음
 * 
 *  메소드 명세에 기술한 예외는 발생하더라도
 * 객체 상태가 유지되는 것이 기본 규칙
 * 이 규칙을 지키지 못한다면
 * 실패 시 객체 상태를 설명에 명시하는 것이 이상적
 * 
 *
 *
 */
public class item76 {
}
