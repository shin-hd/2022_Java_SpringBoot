package ch12.item85;

/*
 * item85. 자바 직렬화의 대안을 찾으라
 *
 *  직렬화의 근본적인 문제
 * : 공격 범위가 넓고 지속적으로 더 넓어져서 방어가 힘듦
 * 바이트 스트림을 역직렬화하는 과정에서 타입 안의 모든 코드를 수행할 수 있는데,
 * 그 말은 타입의 코드 전체가 공격 범위에 들어간다는 것을 의미
 *
 *  CERT 기술 관리자 로버트 시커드
 * "신뢰할 수 없는 스트림을 역직렬화하면 원격 코드 실행, 서비스 거부 등의 공격으로 이루어 질 수 있다"
 * 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메소드 : 가젯
 * 여러 가젯을 함께 사용 : 가젯 체인
 * 강력한 가젯 체인으로 공격당하는 사례가 여럿 있었음
 *
 *  역직렬화 시간이 오래 걸리는 짧은 스트림 : 역직렬화 폭탄
 * 역직렬화 폭탄을 역직렬화하는 것만으로 서비스 거부 공격에 쉽게 노출
 * 역직렬화가 영원히 계속되며, 무언가 잘못되었다는 신호도 없음
 *
 *  직렬화 위험을 피하는 가장 좋은 방법
 * : 아무것도 역직렬화하지 않는 것
 * 새로운 시스템에서 직렬화를 쓸 이유가 전혀 없음
 * 객체와 바이트 시퀀스를 변환하는 메커니즘이 많이 있음
 * : (자바 직렬화와 마찬가지로) 직렬화 시스템, 크로스-플랫폼 구조화된 데이터 표현
 * 
 *  크로스-플랫폼 구조화된 데이터 표현들의 공통점
 * - 자바 직렬화보다 훨씬 간단
 * - 임의 객체 그래프를 자동으로 직렬화/역직렬화하지 않음
 * - 속성-값 쌍의 집합으로 구성된 간단하고 구조화된 데이터 객체 사용
 * - 기본 타입 몇 개와 배열 타입만 지원
 *
 *  크로스-플랫폼 구조화된 데이터 표현의 선두주자들
 * - JSON
 *  브라우저-서버 통신용으로 설계
 *  JavaScript 용으로 만들어졌었음
 * - 프로토콜 버퍼
 *  구글이 서버 사이에 데이터를 교환하고 저장하기 위해 설계
 *  C++용으로 만들어졌었음
 * 지금은 언어 중립적
 *
 *  JSON과 프로토콜 버퍼의 차이점
 * - JSON은 텍스트 기반이라 사람이 읽을 수 있고,
 *   프로토콜 버퍼는 이진 표현이라 효율이 높음
 * - JSON은 데이터를 표현하는 데에만 쓰임
 *   프로토콜 버퍼는 문서를 위한 스키마를 제공하고 올바르게 쓰도록 강요
 *
 *  자바 직렬화를 배제할 수 없을 때의 차선책
 * : 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는 것
 *
 *  직렬화를 배제할 수 없고 역직렬화한 데이터의 안전을 확신할 수 없는 경우
 * : 객체 역직렬화 필터링을 사용
 * 객체 역직렬화 필터링은 데이터 스트림이 역직렬화되기 전에 필터를 설치하는 기능
 *  '기본 수용' 모드
 * 블랙리스트에 기록된 잠재적 위험 클래스들을 거부
 *  '기본 거부' 모드
 * 화이트리스트에 기록된 안전하다고 알려진 클래스들만 수용
 * 화이트리스트 방식이 더 안전하므로 추천
 *
 */
public class item85 {
}
