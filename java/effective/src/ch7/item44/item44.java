package ch7.item44;

/*
 * item44. 표준 함수형 인터페이스를 사용하라
 *
 *  자바가 람다를 지원하면서 상위 클래스 기본 메소드를 재정의해
 * 원하는 동작을 구현하는 템플릿 메소드 패턴의 매력이 크게 줄었음
 * 이를 대체하는 현대적 해법은 같은 효과의 함수 객체를 받는
 * 정적 팩토리나 생성자를 제공하는 것
 *  java.util.function 패키지에는 다양한 용도의 표준 함수형 인터페이스가 담겨 있으므로,
 * 필요한 용도에 맞는 게 있다면 직접 구현하기보다 표준 함수형 인터페이스를 활용
 * 그러면 API가 다루는 개념 수가 줄어들어 익히기 더 쉬워지고,
 * 유용한 디폴트 메소드를 많이 제공하므로 상호운용성이 크게 좋아짐
 *  java.util.function 패키지에는 총 43개의 인터페이스가 담겨 있음
 * 기본 인터페이스 6개만 기억하면 나머지를 충분히 유추 가능
 *  Operator 인터페이스는 인수가 1개인 UnaryOperator와
 * 인수가 2개인 BinaryOperator로 나뉘며,
 * 반환값과 인수 타입이 같은 함수
 *  Predicate 인터페이스는 인수 하나를 받아 boolean을 반환하는 함수
 *  Function 인터페이스는 인수와 반환 타입이 다른 함수
 *  Supplier 인터페이스는 인수를 받지 않고 값을 반환하는 함수
 *  Consumer 인터페이스는 인수를 하나 받고 반환은 없는 함수
 *  기본 인터페이스는 기본 타입인 int, long, double용으로
 * 각 3개의 변형이 생겨남
 * 이름도 기본 인터페이스 이름 앞에 해당 기본 타입 이름을 붙여 지었음
 * ex) int Predicate        => IntPredicate
 *     long BinaryOperator  => LongBinaryOperator
 * 유일하게 Function 변형만 반환 타입이 매개변수화됨
 * ex) LongFunction<int[]>는 long 인수를 받아 int[]를 반환
 *  Function 인터페이스에는 기본 타입을 반환하는 변형이 총 9개가 더 있음
 * 입력과 결과 타입이 모두 기본 타입이면 SrcToResult를 접두어로 사용
 * ex) long 받고 int 반환 => LongToIntFunction
 * 입력이 객체 참조이고 결과가 기본 타입이면 접두어로 ToResult를 사용
 * ex) int[] 받고 long 반환 => ToLongFunction<int[]>
 *  기본 함수형 인터페이스 중 3개에는 인수를 2개씩 받는 변형이 존재
 * BiPredicate<T, U>
 * BiFunction<T, U, R>
 *  (기본타입을 반환하는 세 변형)
 *  ToIntBiFunction<T, U>
 *  ToLongBiFunction<T, U>
 *  ToDoubleBiFunction<T, U>
 * BiConsumer<T, U>
 *  BooleanSupplier 인터페이스는 boolean 반환하도록 한 Supplier의 변형
 * boolean을 명시한 유일한 인터페이스
 * 다 외우기에는 수도 많고 규칙성도 부족하지만,
 * 실무에서 자주 쓰이는 함수형 인터페이스 중 상당수를 제공하므로,
 * 찾아 쓸 수 있을 만큼의 범용적 이름을 사용함
 *  표준 함수형 인터페이스 대부분은 기본 타입만 지원하지만,
 * 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말아야 함
 * 성능이 느려질 수 있음
 *  대부분의 상황에서는 직접 작성하는 것보다 표준 함수형 인터페이스를 사용하는 것이 낫지만,
 * 직접 작성해야 할 때도 있음
 * 표준 인터페이스에 필요한 용도에 맞는 게 없는 경우 당연히 직접 작성
 * 그런데 구조적으로 똑같은 표준 함수형 인터페이스가 있더라도
 * 직접 작성해야 하는 경우가 있음
 * 다음 세 가지 중 하나 이상을 만족한다면 함수형 인터페이스 구현을 고려해야 함
 * - 자주 쓰이며, 이름 자체가 용도를 명확히 설명함
 * - 반드시 따라야 하는 규약이 있음
 * - 유용한 디폴트 메소드를 제공할 수 있음
 * 전용 함수형 인터페이스를 작성하기로 했다면, 인터페이스임을 명심해야 함
 *  직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 어노테이션을 사용해야 함
 * 1. 해당 클래스의 코드나 설명 문서를 읽을 사람에게 람다용으로 설계된 것임을 알려줌
 * 2. 인터페이스가 추상 메소드를 오직 하나만 가지고 있어야 컴파일되게 해줌
 * 3. 유지보수 과정에서 누가 실수로 메소드를 추가하지 못하게 막아줌
 *  함수형 API를 사용할 때 서로 다른 함수형 인터페이스를
 * 같은 위치의 인수로 받는 메소드를 다중 정의해서는 안됨
 * 헷갈리니까
 * 
 */
public class item44 {
}
