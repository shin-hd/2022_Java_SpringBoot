package ch11.item79;

/*
 * item79. 과도한 동기화는 피하라
 *
 *  과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고,
 * 예측할 수 없는 동작을 낳음
 *
 * 1. 정확성 측면
 * 동기화 영역에서는 가능한 한 일을 적게 해야 함
 *  응답 불가와 안전 실패를 피하려면 동기화 메소드나 동기화 블록 안에서는
 * 제어를 절대로 클라이언트에 양도하면 안 됨
 * 동기화된 영역을 포함한 클래스 관점에서는
 * 재정의할 수 있는 메소드나 클라이언트로부터 넘겨받은 함수 객체는
 * 통제할 수 없는 외계인 메소드임
 *  외계인 메소드 때문에 동기화된 영역은 문제을 일으킬 수 있음
 * => 외계인 메소드 호출을 동기화 블록 바깥으로 옮기면 해결
 * 
 *  동시성 컬렉션 라이브러리의 CopyOnWriteArrayList 사용하면 쉽게
 * 외계인 메소드 호출을 동기화 블록 바깥으로 옮길 수 있음
 * CopyOnWriteArrayList는 수정할 일은 드물고
 * 순회만 빈번한 옵저버 리스트 용도로 최적화되어 있음
 *
 *  동기화 영역 바깥에서 외계인 메소드를 호출 : 열린 호출
 * 실패 방지 효과와 동시성 효율 개선 효과를 가져옴
 *
 * 2. 성능 측면
 *  멀티코어가 일반화된 이후, 과도한 동기화의 진짜 비용은
 * 락을 얻는 데 드는 시간이 아니라, 병렬로 실행할 기회를 잃고
 * 모든 코어가 메모리를 일관되게 보기 위한 지연시간
 *  가변 클래스를 작성할 때 따라야 하는 선택지
 * 1) 동기화를 전혀 하지 말고, 클래스를 동시에 사용해야 하는
 *    클래스가 외부에서 알아서 동기화하도록 하기
 * 2) 동기활를 내부에서 수행해 스레드 안전한 클래스로 만들기
 * 클라이언트가 외부에서 객체 전체에 락을 거는 것보다
 * 동시성을 월등히 개선할 수 있을 때만 두 번째 방법을 선택해야 함
 * 선택하기 어렵다면 동기화하지 않고,
 * 문서에 "스레드 안전하지 않다"고 명기
 *  내부에서 동기화하기로 했다면, 락 분할, 락 스트라이핑,
 * 비차단 동시성 제어 등 다양한 기법을 동원할 수 있음
 *
 */
public class item79 {
}
