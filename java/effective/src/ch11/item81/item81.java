package ch11.item81;

/*
 * item 81. wait와 notify보다는 동시성 유틸리티를 애용하라
 *
 *  고수준 동시성 유틸리티가 wait와 notify의 일을 대신 처리해주며,
 * wait와 notify는 올바르게 사용하기 까다롭기 때문에 동시성 유틸리티를 사용하난게 나음
 *
 *  java.util.concurrent의 고수준 유틸리티 세 범주
 * 1. 실행자 프레임워크
 *  item 80 참고.
 *
 * 2. 동시성 컬렉션
 *  List, Queue, Map 같은 표준 컬렉션 인터페이스에
 * 동시성을 가미해 구현한 고성능 클래스
 * 동기화를 각자의 내부에서 수행하므로 동시성을 무력화하는것은 불가능
 * 외부에서 락을 사용하면 속노를 느려지게 함
 *  동시성을 무력화하지 못해서 여러 메소드를 원자적으로 묶어 호출하지 못함
 * => 여러 기본 동작을 하나의 원자적 동작으로 묶은 '상태 의존적 수정' 메소드가 추가됨
 *  ConcurrentMap은 동시성이 뛰어나며 속도도 매우 빨라서
 * Collections.synchronizedMap 대신 ConcurrentMap을 사용하는 것으로
 * 성능이 극적으로 개선됨
 *
 * 3. 동기화 장치
 *  스레드가 다른 스레드를 기다릴 수 있게 해서,
 * 서로 작업을 조율할 수 있게 해줌
 *  CountDownLatch는 일회성 장벽,
 * 하나 이상의 스레드가 또다른 하나 이상의 스레드의 작업이 끝날 때까지 기다리게 함
 * ex) 다른 스레드의 결과를 받아서 작업하는 스레드
 *  executor는 concurrency 동시성 수준만큼 스레드 실행 가능해야 함
 * 그렇지않으면 스레드 기아 교착상태에 빠져 메소드가 끝나지 못함
 *
 *  레거시 코드를 다룰 때 wait과 notify가 사용되었을 수 있음
 *  wait 메소드는 스레드가 어떤 조건이 충족되기를 기다리게 할 때 사용
 * wait loop 관용구를 사용하며 반복문 밖에서는 절대 호출하면 안 됨
 *  조건을 만족하지 않았는데 스레드가 깨어날 수 있는 상황
 * - 스레드가 notify를 호출한 다음 대기중인 스레드가 깨어나는 사이에
 *   다른 스레드가 락을 얻어 보호하고있는 상태를 변경
 * - 다른 스레드가 실수로 notify를 호출
 * - 일부 스레드만 조건을 만족했는데 notifyAll로 모든 스레드를 깨움
 * - norify 없이 깨어난 허위 각성(spurious wakeup) 현상 발생
 *
 *  모든 스레드가 같은 조건을 기다리고,
 * 조건 한 번 충족 -> 스레드 하나 혜택
 * => notify 사용 가능
 *  하지만 notify는 관련 없는 스레드의 악의적인 wait으로 보호가 불가능해서
 * notifyAll이 안전함
 *
 *
 */
public class item81 {
}
