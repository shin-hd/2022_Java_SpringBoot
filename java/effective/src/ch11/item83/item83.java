package ch11.item83;

/*
 * item83. 지연 초기화는 신중히 사용하라
 *
 *  지연 초기화
 * : 필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법
 * 주로 최적화 용도로 쓰이며, 초기화 시 발생하는 순환 문제를 해결하는데도 효과가 있음
 *
 *  지연 초기화는 필요할 때만 해야 함
 * 지연 초기화는 생성 시의 초기화 비용은 줄지만
 * 지연 초기화 필드 접근 비용은 커짐
 * => 지연 초기화 필드의 초기화 비율, 접근 빈도에 따라
 *    오히려 성능을 저하시킬 수 있음
 * 
 *  지연 초기화가 필요한 상황
 * - 어떤 필드를 사용하는 인스턴스 비율이 낮고,
 *   그 필드를 초기화하는 비용이 큰 경우
 * => 지연 초기화 적용 전후 성능 측정 필요
 *
 *  지연 초기화하는 필드를 스레드들이 공유한다면 동기화가 필요함
 *
 * - 대부분 상황
 *  일반적인 초기화 > 지연 초기화
 * 
 * - 성능 때문에 정적 필드를 지연 초기화
 *  => 지연 초기화 홀더 클래스 관용구를 사용
 *  private static class FieldHolder {
 *   static final FieldType field = computeFieldValue();
 *  }
 *  FieldHolder.field 에 접근하려는 순간 초기화되며
 *  getField가 동기화를 하지 않아 성능이 느려질 거리가 없음
 * 
 * - 성능 때문에 인스턴스 필드를 지연 초기화
 *  => 이중검사 관용구를 사용
 *  필드값을 첫 번째는 동기화 없이, 두 번째는 동기화해서 검사하는 방식
 *  초기화된 필드에 접근 시 동기화 비용을 없애줌
 *
 *  이중검사 변종 두 가지
 * - 단일검사 관용구
 *  이중검사에서 두 번째 검사를 생략
 *  반복해서 초기화해도 상관없는 인스턴스 필드를 지연 초기화할 때 사용
 * - 짜릿한 단일검사 관용구
 *  단일검사 필드 선언에서 volatile 한정자를 제거
 *  모든 스레드가 필드 값을 다시 계산해도 상관 없는
 *  long과 double이 아닌 기본 타입일 때 사용
 *  필드 접근 속도를 높여주지만, 초기화가 스레드당 최대 한 번 더 이뤄질 수 있음
 *
 *
 *
 */
public class item83 {
    /* 코드 83-4. 이중검사 관용구
    private volatile FieldType field;
    private FieldType getField() {
        FieldType result = field; // 이미 초기화되있을 때 한 번만 읽도록 보장
        if (result != null) // 락 사용 x
            return result;
        
        synchronized(this) {
            if (field == null) // 락 사용
                field = computeFieldValue();
            return field;
        }
     }
     */
}
