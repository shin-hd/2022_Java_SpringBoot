package ch11.item80;

/*
 * item80. 스레드보다는 실행자, 태슼, 스트림을 애용하라
 * 
 *  java.util.concurrent 패키지는 실행자 프레임워크라고 하는
 * 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있음
 * - 작업 큐 생성
 *  ExecutorService exec = Executors.newSingleThreadExecutor();
 * - 실행할 태스크 넘기기
 *  exec.execute(runnable);
 * - 실행자 종료
 *  exec.shutdown();
 * 
 *  실행자 서비스의 주요 기능
 * - 특정 태스크가 완료되기를 기다림
 * - 태스크 모음 중 아무것 하나 혹은 모든 테스크가 완료되기를 기다림
 * - 실행자 서비스가 종료하기를 기다림
 * - 완료된 태스크들의 결과를 차례로 받음
 * - 태스크를 특정 시간에 혹은 주기적으로 실행하게 함
 *
 *  java.util.concurrent.Executors의 정적 팩토리들을 이용하면
 * 필요한 실행자 대부분을 생성할 수 있음
 * 원한다면 ThreadPoolExecutor 클래스를 직접 사용해도 됨
 *  작은 프로그램이나 가벼운 서버
 * => Executors.newCachedThreadPool (스레드를 계속 생성)
 *  무거운 프로덕션 서버
 * => Executors.newFixedThreadPool (스레드 개수 고정)
 *    ThreadPoolExecutor를 직접 사용 (완전 통제)
 * 
 *  작업 큐를 손수 만드는 일과 스레드를 직접 다루는 것은 삼가야 함
 * 스레드를 직접 다루면
 * - Thread가 작업 단위와 수행 메커니즘 역할을 모두 수행
 * 실행자 프레임워크를 사용하면
 * - 작업 단위와 실행 메커니즘이 분리뒴
 * 
 *  태스크의 종류
 * - Runnable
 * - Callable
 *  Runnable과 비슷하지만 값을 반환하고 임의의 예외를 던질 수 있음
 *
 *  태스크를 수행하는 일반적인 매커니즘 : 실행자 서비스
 * 태스크 수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책을 선택 가능
 * 수행 정첵은 언제든 변경 가능
 *
 *  실행자 프레임워크는 포크-조인 태스크를 지원하도록 확장
 * 포크-조인 테스크는 포크-조인 풀이라는 특별한 실행자 서비스가 실행
 * 모든 스레드가 CPU를 최대한 활용해서 높은 처리량과 낮은 지연시간 달성
 * 단, 포크-조인에 적합한 형태의 작업이어야 함
 * 
 * 
 *
 */
public class item80 {
}
